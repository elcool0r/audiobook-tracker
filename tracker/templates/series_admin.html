{% extends 'base.html' %}
{% block content %}
<div class="container-fluid px-3 px-sm-4">
<h1 id="seriesAdminTitle">Series</h1>
{% if settings.developer_mode and user.role == 'admin' %}
<div class="alert alert-warning small">Developer mode is active — duplication controls are available in the list.</div>
{% endif %}
<div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-3">
  <div class="input-group" style="max-width: 320px;">
    <input id="filter" class="form-control" placeholder="Filter by title" />
    <button class="btn btn-outline-secondary" id="clearFilter">Clear</button>
  </div>
  <div class="d-flex align-items-center gap-2">
    <button id="seriesPrev" class="btn btn-sm btn-outline-secondary" disabled>Prev</button>
    <span id="seriesPagerInfo" class="text-muted small"></span>
    <button id="seriesNext" class="btn btn-sm btn-outline-secondary" disabled>Next</button>
    <div class="d-flex align-items-center gap-1">
      <label class="mb-0 small" for="seriesPageSize"></label>
      <select id="seriesPageSize" class="form-select form-select-sm">
        <option value="10">10</option>
        <option value="20">20</option>
        <option value="50">50</option>
      </select>
    </div>
  </div>
</div>
<div id="seriesList"></div>
<script type="application/json" id="user-date-format">"{{ user.date_format or 'iso' }}"</script>
<script type="application/json" id="developer-mode-enabled">{{ 'true' if settings.developer_mode else 'false' }}</script>
<script type="application/json" id="is-admin">{{ 'true' if user.role == 'admin' else 'false' }}</script>
<script>
let allSeries = [];
const userDateFormat = JSON.parse(document.getElementById('user-date-format').textContent);
const developerModeEnabled = JSON.parse(document.getElementById('developer-mode-enabled').textContent);
const developerControlsVisible = developerModeEnabled && JSON.parse(document.getElementById('is-admin').textContent);
let currentPage = 1;
let totalSeries = 0;
let totalPages = 1;
let pageSize = 10;
let currentFilter = '';
let sortState = { key: 'title', asc: true };
const sortableColumns = [
  { key: 'title', label: 'Title' },
  { key: 'asin', label: 'ASIN' },
  { key: 'book_count', label: 'Books' },
  { key: 'user_count', label: 'Users' },
  { key: 'fetched_at', label: 'Last Refresh' },
  { key: 'next_refresh_at', label: 'Next Refresh' },
];

function makeCoverIcon(src) {
  if (!src) return null;
  const icon = document.createElement('img');
  icon.src = src;
  icon.alt = 'Cover';
  icon.className = 'me-2 rounded';
  icon.style.width = '18px';
  icon.style.height = '18px';
  icon.style.objectFit = 'cover';
  icon.setAttribute('data-bs-toggle', 'tooltip');
  icon.setAttribute('data-bs-placement', 'right');
  icon.setAttribute('data-bs-html', 'true');
  icon.setAttribute('data-bs-custom-class', 'cover-tooltip');
  icon.setAttribute('title', `<img src="${src}" style="width:180px;height:auto;" />`);
  return icon;
}

function formatDate(val) {
  if (!val) return '';
  try {
    const d = new Date(val);
    if (isNaN(d.getTime())) return val;
    const pad = (n) => n.toString().padStart(2, '0');
    if (userDateFormat === 'de') return `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()}`;
    if (userDateFormat === 'us') return `${pad(d.getMonth()+1)}/${pad(d.getDate())}/${d.getFullYear()}`;
    return d.toISOString().slice(0,10);
  } catch(e) { return val; }
}

function formatDateTime(val) {
  if (!val) return '';
  try {
    const d = new Date(val);
    if (isNaN(d.getTime())) return val;
    const pad = (n) => n.toString().padStart(2, '0');
    const date = userDateFormat === 'de' ? `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()}` :
                 userDateFormat === 'us' ? `${pad(d.getMonth()+1)}/${pad(d.getDate())}/${d.getFullYear()}` :
                 d.toISOString().slice(0,10);
    const time = `${pad(d.getHours())}:${pad(d.getMinutes())}`;
    return `${date} ${time}`;
  } catch(e) { return val; }
}

function setSort(key) {
  if (sortState.key === key) {
    sortState.asc = !sortState.asc;
  } else {
    sortState.key = key;
    sortState.asc = true;
  }
  currentPage = 1;
  loadSeries(1);
}


function render(list) {
  const container = document.getElementById('seriesList');
  container.innerHTML = '';
  if (!list.length) { container.innerHTML = '<div class="alert alert-info">No series found.</div>'; return; }
  const table = document.createElement('table');
  table.className = 'table table-striped table-sm';
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  sortableColumns.forEach(column => {
    const th = document.createElement('th');
    th.scope = 'col';
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'btn btn-link text-decoration-none p-0';
    button.onclick = () => setSort(column.key);
    const labelSpan = document.createElement('span');
    labelSpan.textContent = column.label;
    button.appendChild(labelSpan);
    if (sortState.key === column.key) {
      const arrow = document.createElement('span');
      arrow.className = 'ms-1';
      arrow.textContent = sortState.asc ? '▲' : '▼';
      button.appendChild(arrow);
      th.setAttribute('aria-sort', sortState.asc ? 'ascending' : 'descending');
    }
    th.appendChild(button);
    headerRow.appendChild(th);
  });
  const actionsHeader = document.createElement('th');
  actionsHeader.textContent = '';
  actionsHeader.scope = 'col';
  actionsHeader.className = 'text-end';
  headerRow.appendChild(actionsHeader);
  thead.appendChild(headerRow);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  list.forEach(s => {
    const tr = document.createElement('tr');
    const urlCell = document.createElement('td');
    if (s.asin) {
      const coverSrc = s.cover_image || null;
      const coverIcon = makeCoverIcon(coverSrc);
      if (coverIcon) urlCell.appendChild(coverIcon);
      const a = document.createElement('a');
      a.href = (window.BASE_PATH || '') + '/series-books?asin=' + encodeURIComponent(s.asin);
      a.textContent = s.title || '(untitled)';
      urlCell.appendChild(a);
      // Show info icon when narrator-change ignore is enabled for this series
      if (s.ignore_narrator_warnings) {
        const info = document.createElement('span');
        info.className = 'ms-2 text-info ignore-narrator-icon';
        info.setAttribute('data-bs-toggle', 'tooltip');
        info.setAttribute('data-bs-placement', 'right');
        info.setAttribute('title', 'Narrator change detection is ignored for this series. Warnings and automated narrator changes will be suppressed.');
        info.textContent = 'ℹ';
        urlCell.appendChild(info);
      }    } else {
      urlCell.textContent = s.title || '(untitled)';
    }
    urlCell.style.overflow = 'hidden';
    urlCell.style.textOverflow = 'ellipsis';
    urlCell.style.whiteSpace = 'nowrap';
    tr.appendChild(urlCell);
    const asin = document.createElement('td');
    if (s.asin) {
      const a = document.createElement('a');
      a.href = s.url || '#';
      a.target = s.url ? '_blank' : '';
      a.rel = s.url ? 'noreferrer noopener' : '';
      // Extract ASIN from URL (which is authoritative) for display
      if (s.url) {
        const urlMatch = s.url.match(/\/([A-Z0-9]+)(?:\?|$)/);
        a.textContent = (urlMatch && urlMatch[1]) || s.asin;
      } else {
        a.textContent = s.asin;
      }
      asin.appendChild(a);
    } else {
      asin.textContent = '';
    }
    tr.appendChild(asin);
    const books = document.createElement('td'); books.textContent = s.book_count || 0; tr.appendChild(books);
    const users = document.createElement('td'); users.textContent = s.user_count || 0; tr.appendChild(users);
    const fetched = document.createElement('td'); fetched.textContent = formatDateTime(s.fetched_at); tr.appendChild(fetched);
    const nextRefresh = document.createElement('td'); nextRefresh.textContent = formatDateTime(s.next_refresh_at); tr.appendChild(nextRefresh);
    const actions = document.createElement('td');
    actions.className = 'text-end';

    // Build a dropdown to contain per-row actions
    const btnGroup = document.createElement('div');
    btnGroup.className = 'btn-group';

    const dropdownToggle = document.createElement('button');
    dropdownToggle.className = 'btn btn-sm btn-outline-secondary dropdown-toggle';
    dropdownToggle.type = 'button';
    dropdownToggle.setAttribute('data-bs-toggle', 'dropdown');
    dropdownToggle.setAttribute('aria-expanded', 'false');
    dropdownToggle.textContent = 'Actions';

    const dropdownMenu = document.createElement('ul');
    dropdownMenu.className = 'dropdown-menu dropdown-menu-end';

    function addMenuItem(text, onclick, opts) {
      const li = document.createElement('li');
      const btnItem = document.createElement('button');
      btnItem.type = 'button';
      btnItem.className = 'dropdown-item';
      if (opts && opts.className) btnItem.classList.add(opts.className);
      btnItem.textContent = text;
      btnItem.onclick = onclick;
      if (opts && opts.disabled) btnItem.disabled = true;
      li.appendChild(btnItem);
      dropdownMenu.appendChild(li);
      return btnItem;
    }

    // Series-level ignore narrator change toggle
    if (s.asin && ((Array.isArray(s.narrator_warnings) && s.narrator_warnings.length > 0) || Boolean(s.ignore_narrator_warnings))) {
      addMenuItem(s.ignore_narrator_warnings ? 'Unignore narrator changes' : 'Ignore narrator changes', async () => {
        if (!s.asin) return;
        const desired = !Boolean(s.ignore_narrator_warnings);
        try {
          const resp = await fetch(apiPath(`/api/series/${encodeURIComponent(s.asin)}/ignore-narrator-series`), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ignore: desired }),
          });
          if (!resp.ok) throw new Error(await resp.text() || 'Failed');
          const data = await resp.json();
          s.ignore_narrator_warnings = Boolean(data.ignore_narrator_warnings);
          loadSeries(currentPage);
        } catch (err) {
          alert(err?.message || 'Failed to toggle series ignore');
        }
      });
    }

    // Refresh books
    addMenuItem('Refresh books', async () => {
      const btn = event.currentTarget;
      btn.disabled = true; btn.textContent = 'Enqueued...';
      try {
        const resp = await fetch(apiPath(`/api/series/${encodeURIComponent(s.asin)}/refresh`), { method: 'POST', headers: { 'Content-Type': 'application/json' } });
        if (resp.ok) {
          const data = await resp.json();
          btn.textContent = 'Job: ' + (data.job_id || 'ok');
        } else {
          btn.textContent = 'Error';
        }
      } catch (e) {
        btn.textContent = 'Error';
      }
      setTimeout(() => { btn.disabled = false; btn.textContent = 'Refresh books'; }, 3000);
    });

    // Rename title
    addMenuItem('Rename title', async () => {
      if (!s.asin) return;
      const currentTitle = s.title || '';
      const message = currentTitle ? `New display title for "${currentTitle}"?` : 'New display title for series?';
      const input = prompt(message, currentTitle);
      if (input === null) return;
      const trimmed = input.trim();
      if (!trimmed) { alert('Title cannot be empty'); return; }
      const btn = event.currentTarget;
      btn.disabled = true; btn.textContent = 'Saving...';
      try {
        const resp = await fetch(apiPath(`/api/series/${encodeURIComponent(s.asin)}/title`), {
          method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ title: trimmed })
        });
        if (resp.ok) { await loadSeries(); return; }
        btn.textContent = 'Error';
        setTimeout(() => { btn.disabled = !s.asin; btn.textContent = 'Rename title'; }, 2000);
      } catch (err) { btn.textContent = 'Error'; setTimeout(() => { btn.disabled = !s.asin; btn.textContent = 'Rename title'; }, 2000); }
    });

    if (developerControlsVisible && s.asin) {
      addMenuItem('Duplicate', async () => {
        const suggested = `${s.asin}-dev-${Date.now()}`;
        const target = prompt('Enter mock ASIN for duplicate', suggested);
        if (!target) return; const trimmed = target.trim(); if (!trimmed) { alert('ASIN cannot be empty'); return; }
        const btn = event.currentTarget; btn.disabled = true; btn.textContent = 'Duplicating...';
        try {
          const resp = await fetch(apiPath(`/api/developer/series/${encodeURIComponent(s.asin)}/duplicate`), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ target_asin: trimmed }) });
          if (!resp.ok) throw new Error(await resp.text() || 'Duplicate failed');
          const data = await resp.json(); alert(`Series duplicated as ${data.asin}`); loadSeries(currentPage);
        } catch (err) { alert(err?.message || 'Failed to duplicate series'); }
        finally { btn.disabled = false; btn.textContent = 'Duplicate'; }
      });

      addMenuItem('Probe now', async () => {
        const btn = event.currentTarget; btn.disabled = true; btn.textContent = 'Scheduling...';
        try {
          const resp = await fetch(apiPath(`/api/developer/series/${encodeURIComponent(s.asin)}/probe`), { method: 'POST', headers: { 'Content-Type': 'application/json' } });
          if (resp.ok) { const data = await resp.json(); btn.textContent = data.job_id ? `Job ${data.job_id}` : 'Queued'; }
          else { const text = await resp.text(); btn.textContent = 'Error'; alert(text || 'Failed to schedule probe'); }
        } catch (err) { btn.textContent = 'Error'; alert(err?.message || 'Failed to schedule probe'); }
        finally { setTimeout(() => { btn.disabled = false; btn.textContent = 'Probe now'; }, 3000); }
      });
    }

    // Delete (two-step confirm)
    addMenuItem('Delete', async (event) => {
      // Prevent dropdown from auto-closing so the user can confirm
      try { event.stopPropagation(); } catch (e) {}
      const btn = event.currentTarget;
      if (btn.dataset.confirmed !== 'true') {
        btn.dataset.confirmed = 'true';
        btn.textContent = 'Confirm';
        btn.classList.add('text-danger');
        // keep dropdown-item class for consistent styling
        setTimeout(() => {
          if (btn.dataset.confirmed === 'true') {
            btn.dataset.confirmed = '';
            btn.textContent = 'Delete';
            btn.classList.remove('text-danger');
          }
        }, 3000);
        return;
      }
      btn.disabled = true; btn.textContent = 'Deleting...';
      try {
        const resp = await fetch(apiPath(`/api/series/${encodeURIComponent(s.asin)}`), { method: 'DELETE' });
        if (resp.ok) { await loadSeries(); }
        else { btn.textContent = 'Error'; setTimeout(() => { btn.disabled = false; btn.textContent = 'Delete'; }, 3000); }
      } catch (err) { btn.textContent = 'Error'; setTimeout(() => { btn.disabled = false; btn.textContent = 'Delete'; }, 3000); }
    });

    btnGroup.appendChild(dropdownToggle);
    btnGroup.appendChild(dropdownMenu);
    actions.appendChild(btnGroup);
    tr.appendChild(actions);
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  const wrapper = document.createElement('div');
  wrapper.appendChild(table);
  container.appendChild(wrapper);
  try {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(function (tooltipTriggerEl) { new bootstrap.Tooltip(tooltipTriggerEl); });
  } catch (e) { /* non-fatal */ }
  // Footer summary: earliest next refresh across series
  const footer = document.createElement('div');
  const times = list.map(s => s.next_refresh_at).filter(Boolean).sort();
  if (times.length) {
    footer.className = 'small text-muted mt-2';
    footer.textContent = 'Next refresh scheduled at: ' + formatDateTime(times[0]);
    container.appendChild(footer);
  }
}

function updatePager() {
  const pagerInfo = document.getElementById('seriesPagerInfo');
  pagerInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalSeries} total, ${pageSize} per page)`;
  document.getElementById('seriesPrev').disabled = currentPage <= 1;
  document.getElementById('seriesNext').disabled = currentPage >= totalPages;
}

async function loadSeries(page = currentPage) {
  const params = new URLSearchParams({ page: String(page), page_size: String(pageSize) });
  if (currentFilter) {
    params.set('filter', currentFilter);
  }
  if (sortState.key) {
    params.set('sort', sortState.key);
    params.set('order', sortState.asc ? 'asc' : 'desc');
  }
  const r = await fetch(apiPath(`/api/series?${params.toString()}`));
  if (!r.ok) {
    document.getElementById('seriesList').innerHTML = '<div class="alert alert-danger">Forbidden</div>';
    return;
  }
  const payload = await r.json();
  allSeries = payload.series;
  totalSeries = payload.total;
  totalPages = payload.total_pages;
  currentPage = payload.page;
  document.getElementById('seriesAdminTitle').textContent = `Series (${totalSeries})`;
  render(allSeries);
  updatePager();
}

document.getElementById('filter').addEventListener('input', (event) => {
  currentFilter = (event.target.value || '').trim();
  currentPage = 1;
  loadSeries(1);
});

document.getElementById('clearFilter').addEventListener('click', () => {
  document.getElementById('filter').value = '';
  currentFilter = '';
  currentPage = 1;
  loadSeries(1);
});

document.getElementById('seriesPrev').addEventListener('click', () => {
  if (currentPage > 1) {
    loadSeries(currentPage - 1);
  }
});
document.getElementById('seriesNext').addEventListener('click', () => {
  if (currentPage < totalPages) {
    loadSeries(currentPage + 1);
  }
});
const pageSizeSelect = document.getElementById('seriesPageSize');
pageSizeSelect.value = String(pageSize);
pageSizeSelect.addEventListener('change', () => {
  const val = parseInt(pageSizeSelect.value, 10);
  if (isNaN(val) || val <= 0) {
    pageSizeSelect.value = String(pageSize);
    return;
  }
  pageSize = val;
  currentPage = 1;
  loadSeries(1);
});

loadSeries();

</script>
</div>
{% endblock %}
